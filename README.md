# hw-test


# 사용한 디자인 패턴
1. Factory Method Pattern
2. Abstract Factory Pattern
3. State Pattern
4. Mediator Pattern

이번 과제에서 공부한 패턴은 위와 같다. <br>
먼저 수업 시간에 Factory Method 패턴에 대해 다루며 Abstract Factory 패턴과 어떤 차이가 있는지 궁금했고,<br>
각 패턴은 어떤 특징이 있으며 어떠한 상황에서 Factory Method 패턴 혹은 Abstract Factory 패턴을 쓰는지에 대해 고민해보며 정리하였다. <br>
다음으로 수업 시간에 State 패턴에 대해 공부하며 발생했던 문제를 Mediator 패턴을 통해 해결할 수 있다는 생각이 들어 정리해보았다. <br>

## Simple Factory Pattern
팩토리 패턴에는 Factory Method 패턴과 Abstract Factory 패턴이 있다. 이 두가지 패턴에 앞서 Simple Factory 패턴에 대해 정리하였다.<br>
Simple Factory Pattern은 간단히 말해 객체를 생성하는 클래스를 따로 두는 패턴을 말한다. <br>
factory_pattern 패키지의 SimplePhoneFactory 클래스를 보면 createPhone 메서드의 switch문를 통해 <br>
클라이언트가 주문할 휴대폰의 객체를 직접 생성하는 것을 볼 수 있다. <br>
심플 팩토리는 단순히 객체를 만드는 작업을 하나의 팩토리 클래스에 모아두는 것을 의미한다. <br>

## Factory Pattern
팩토리 메소드 패턴의 정의는 아래과 같다.<br>

객체를 생성하기 위한 인터페이스를 정의하는 과정에서 어떤 클래스의 인스턴스를 만들지는 서브클래스에서 결정한다. <br>
즉, 클래스의 인스턴스를 만드는 일을 서브클래스에게 맡기는 것이다. <br>

다시 말해 심플 팩토리 패턴에서 createPhone() 부분에서 Factory에서 직접 객체를 만드는 것을 Factory를 상속한 서브클래스에서 객체를 만들게끔 하는 것이 팩토리 메소드 패턴이다. <br>

![image](https://github.com/wnsdnjs70/hw-test/assets/43106344/776e2ff7-e24e-4b4b-98f8-e10371e8ebed)
![image](https://github.com/wnsdnjs70/hw-test/assets/43106344/53254d33-08ff-4fce-9bd3-9a5fd8ea515a)

UML 다이어그램과 코드를 매핑해보면 아래와 같다. <br>
PhoneFactory : Creator <br>
AndroidPhoneFactory, IPhoneFactory : ConcreteCreator<br>
AndroidPhone, IPhone : Product<br>

### Simple Factory Method 와의 차이점
먼저 휴대폰 객체를 직접 생성하는 SimplePhoneFactory 클래스를 인터페이스화 했다. <br>
그리고 구현체로 IPhoneFactory, AndroidPhoneFactory를 만들고 createPhone()메서드를 통해 각자의 Factory에서 Phone 객체의 구현체인 IPhone과 AndroidPhone을 만들었다. <br>
이를 통해 서브클래스(IPhoneFactory,AndroidPhoneFactory)에서 어떤 객체를 생성할지 결정할 수 있어야 한다는 팩토리 메서드 패턴의 정의를 충족할 수 있다. <br>
이렇게 구조를 잡는다면 추후 아이폰, 안드로이드폰의 종류가 여러개로 늘어난다 해도 Phone구현체 클래스의 생성과 createPhone()의 분기처리만 해줌으로써 확장에 열려 있는 구조가 된다.  <br>
즉, 팩토리 메서드 패턴을 통해 확장에는 열려있고 변경에는 닫혀있어야 한다는 OCP (개방 폐쇄의 원칙 : Open Close Principle) 를 만족할 수 있다. <br>


# Udemy 강의 정리

### ENI

ENI는 하나당 사설 ip 1개와 공용 ip 한개를 배정받을 수 있다. 

EC2 인스턴스에서 다른 EC2인스턴스로 액세스 하고 싶을 때 eni를 옮겨주면 된다 ?

직접 만든 eni는 제어가 가능하므로 원하는 인스턴스에 붙여서 액세스해서 작업하기 좋다. 

다만 ENI는 AZ에 종속되므로 같은 AZ 안에 있는 인스턴스에만 붙일 수 있다. 

인스턴스를 종료하면 default ENI는 사라지지만 직접 만든 ENI는 사라지지 않는다. 

### EC2 Hibernate(절전모드)

절전모드는 램에 있던 인메모리 데이터는 그대로 보존된다. → 인스턴스 부팅이 빨라진다. 

운영체제를 중지하거나 다시 시작하는게 아니라 잠시 멈춰있는 것 뿐 

→ uptime 을 실행해도 0으로 나오지 않는다( OS는 중지된 게 아니라 인식해서)

절전 모드를 실행하면 인스턴스가 중지되고 램의 내용이 EBS에 덤프된다. 

인스턴스를 종료하면 램은 사라진다. 하지만 EBS에 램이 덤프된 내용이 남아있으니 

인스턴스를 다시 시작하면 디스크에서 램을 불러와 인스턴스 메모리로 가져간다.

결론 ⇒ EC2 인스턴스를 중지한 적 없는 것 같은 효과 (램 상태를 저장하거나 재부팅 빨리 하고 싶을 때 사용한다.) uptime 을 실행해도 0으로 나오지 않는다( OS는 중지된 게 아니라 인식해서)

### EBS

- 네트워크 스토리지 이므로 EC2에 떼었다 붙였다 할 수 있음
- EC2에 붙기 때문에 하나의 AZ 안에서만 사용할 수 있음
- 스냅샷을 이용하면 다른 AZ나 다른 리전으로 EBS의 데이터를 옮길 수 있음
- EC2를 생성할 때 루트 EBS는 EC2종료시 자동 삭제 되도록 설정되어 있음
- 추가로 만든 EBS는 EC2종료시 삭제 되도록 설정되어 있지 않음.
- 인스턴스가 삭제될 때 루트 볼륨을 유지하고 싶거나 데이터를 저장하고 싶다면 루트 볼륨의 종료 시 삭제 속성을 해제할 것

### EBS 스냅샷

- EBS 스냅샷 아카이브 : 75% 저렴한 아카이브 티어, 아카이브를 옮길 수 있고 복원하는데 24~72시간이 걸림
- EBS 스냅샷 휴지통(Recycle Bin) : EBS 스냅샷을 삭제하는 경우 바로 삭제되는게 아니라 휴지통에 보관, 1일부터 1년 사이까지 저장 기간 설정 가능
- FSR 빠른 스냅샷 복원 : 스냅샷이 아주 크고 EBS 볼륨 또는 인스턴스를 빠르게 초기화해야 할 때 유용. → 비싸다

### EBS 볼륨의 유형

- gp2 /gp3 : 범용 SSD
- io1 / io2 : 최고 성능의 SSD → 미션 크리티컬 혹은 대용량 워크로드에 사용
- st1  : 저비용의 HDD → 잦은 접근 + 처리량 많은 워크로드에 사용
- sc1 : 초저비용 HDD → 접근 빈도가 낮은 워크로드
- gp2/gp3 + io1/io2 즉, SSD만 부팅 볼륨(루트 OS가 실행될 위치)으로 사용될 수 있다.
- gp3는 IOPS와 처리량을 독자적으로 설정 가능 but, gp2는 둘이 연결되어 있음 (같이증가)
- 데이터베이스 워크로드(16000 IOPS 이상)에는 io1/io2를 이용하는게 좋다.
- st1/sc1 은 빅데이터나 로그 프로세싱에 적합

### EBS 다중 연결

- 같은 EBS를 같은 AZ 내의 다수의 EC2 인스턴스에 연결하게 해주는 것
- io1/io2 에서만 가능
- 최대 16개의 인스턴스까지만 같은 볼륨에 연결 가능

### EBS 암호화

EBS 볼륨을 생성하면 아래와 같은 절차를 거친다.

1. 저장 데이터가 볼륨 내부에 암호화 됨.
2. 인스턴스와 볼륨 간 전송 데이터 또한 암호화 됨
3. 스냅샷으로 생성한 볼륨 역시 암호화 됨.

EBS를 암호화 하는 방법 

→ 복사 기능을 통해 EBS 스냅샷 암호화

→ 스냅샷을 통해 새 EBS를 만들면 그것도 암호화 될 걸?

→ 암호화 된 EBS 볼륨을 인스턴스에 연결

### AMI

- Amazon Machine Image
- EC2 인스턴스를 통해 만든 이미지이다.
- 리전에 국한된다. (다만 다른 리전으로 복제가 가능하긴 하다.)
- 3가지 방법으로 AMI 실행 가능
    - 1 : AWS 에서 제공하는 퍼블릭 AMI
    - 2 : 내가 만든 AMI
    - 3 : AWS market place의 AMI (남이 만든 AMI)

### EC2 인스턴스 스토어

- EC2에 해당하는 물리적 서버에 연결된 하드웨어 드라이브를 가리킴
- 처리량 굿 → I/O 성능 향상을 위해 사용 → I/O 가 빡세다 = 무조건 인스턴스 스토어
- 향상된 디스크 성능을 요할 때 사용
- 단점 : 인스턴스를 종료하면 사라진다. → 버퍼, 캐시, 임시 데이터에 사용
- 데이터를 장기적으로 저장하려면 EBS에 해야함.

### EFS

- File System ⇒ 관리형 네트워크 파일 시스템이다 (NFS)
- 네트워크 파일 시스템이므로 여러 EC2 인스턴스에 마운트 될 수 있다.
- EC2들은 여러 AZ에 있을 수 있따.
- ⇒ EFS는 AZ 밖에 있으므로 AZ에 종속적이지 않다. (가격이 비쌈, gp2의 3배 이상)
- EBS는 설정한 리소스 만큼 돈이 나가는데 EFS는 On Demand임
- 윈도우가 아닌 리눅스에만 호환

### EFS 스토리지 종류

- Standard 계층 : 액세스가 빈번한 파일 ⇒ 다중 AZ로 가용성 제공
- EFS-IA (Infrequent Access) : 파일을 검색할 경우 검색에 대한 비용 발생
- 수명 주기 정책이 있어서 standard 계층에 있는 파일이 설정한 정책을 만족하면 IA로 옮겨감.

### ELB

- Elastic Load Balancer
- 클라이언트의 요청을 받아 다수의 서버로 트래픽을 분기하는 역할
- 서버에 주기적으로 헬스 체크를 해 정상적인 서버로만 트래픽을 분기한다.
- 4가지 종류가 있음
    1. CLB ( Classic Load Balancer) : 구형 로드밸런스
    2. ALB (Application Load Balancer) : 어플리케이션 로드 밸런서
        
        → OSI 7계층 중 7번째 ApplicationLayer에서 동작. HTTP/HTTPS, WebSocket 프로토콜 지원.
        
        → Cross Zone Load Balancing(AZ에 상관없이 전체 인스턴스에 부하를 고르게 분포) 이 default로 설정되어 있음. 
        
        → 여러 개의 SSL 인증서를 두고 리스너를 여러 개 지원할 수 있음. 
        
    3. NLB (Network Load Balancer) : 네트워크 로드 밸런서
        
        → OSI 7계층 중 4번째 Translation Layer에서 동작. TCP / TLS / UDP 프로토콜 지원
        
        → 성능이 매우 좋고 지연 시간이 짧음.
        
        → AZ 별로 하나의 고정 IP를 할당받음 ⇒ 1~3개의 ip를 사용하는 어플리케이션에 유용
        
        → 다중 SSL을 활용해 다중 리스너 지원
        
    4. GWLB (GateWay Load Balancer) : 게이트웨이 로드 밸런서, OSI 7 Layer 중 3 Level 인 네트워크 계층에서 동작. → IP 프로토콜 지원 
        
        → 모든 트래픽이 방화벽을 통과하도록 해 침입 방지 및 탐지 시스템에 유용
        

### ASG

- Auto Scaling Group : 증가한 로드에 맞게 인스턴스 생성, 감소한 로드에 맞게 인스턴스 삭제
- ASG는 무료 서비스이고 새롭게 생성된 리소스에 대한 비용만 지불하면 됨.
- 보통 CloudWatch와 연동하여 Alarm이 생성되면 ASG를 통해 Scale Out 함.
    
    → Alarm은 보통 ASG의 CPU 사용량으로 결정  
    

### ASG 조정 정책

- 대상 추적 스케일링 : 오토 스케일링 그룹의 평균 cpu 사용률을 추적해 일정 수치에 머무르도록
- 단계 스케일링 : CloudWatch 경보 설정 → EC2 추가/제거 로직 설정
- 예약 스케일링 : 기존의 사용 패턴을 바탕으로 스케일링 예약 ex) 금요일 오후 5시에 오토 스케일
- 예측 스케일링 : 과거 로드를 분석해 앞으로의 로드 산정해 스케일링

### RDBMS

- 빈번하고 빠른 데이터 입출력 또는 대량의 복잡한 쿼리 작업에 최적화 됨.
- 환경 구성 방식에 따라 두 가지 유형으로 나뉨.
1. **OLTP : OnLine Transaction Processing 온라인 입출력 처리**
- 데이터에 대한 신속한 접근 → 높은 수준의 메모리 용량
- 충분한 수준의 메모리 및 컴퓨트 용량을 지닌 단일 서버
- 분당 수백만건의 주문을 처리하는 온라인 주문 시스템 등에 활용
1. **OLAP : OnLine Analytic Processing 온라인 분석 처리** 
- 대규모 데이터에 대한 복잡한 쿼리 작업에 적합 → 높은 수준의 컴퓨트 및 스토리지 성능
- 데이터에 대한 체계적인 SQL 쿼리 작업 분산 가능 → 처리 시간 단축
- 여러 개의 서버를 두고 복잡한 쿼리 작업의 처리를 나눠서 처리 → 파티셔닝, 샤딩
- 사용 사례 : 여러 개의 DB가 하나의 큰 DB로 통합되어 있는 어플리케이션에 유용

### Amazon RDS

- 아마존에서 제공하는 관리형 RDBMS 서비스
- DB 초기 설정, 백업, 고가용성 유지, sw 패치, os 관리, DB 복원, 복구, 확장 등 대부분의 작업을 자동으로 수행
- RDS 를 배포하려면 DB 인스턴스를 구성해야 함. → 지정한 VPC 내에 생성 → aws에서 DB 인스턴스 생성의 전 과정을 관리
- DB 인스턴스는 SSH 접속 불가, EC2 인스턴스에서 바로 접근 불가
- 6개의 데이터베이스 엔진을 지원 Mysql, MariaDB, Aurora, Oracle, PostgreSQL, Microsoft SQL
- 스토리지 엔진으로는 InnoDB 권장!

### 데이터베이스 인스턴스

- 사용자는 인스턴스의 연산력, 메모리, 네트워크, 디스크 처리 용량 등등을 먼저 결정
- DB 인스턴스를 사용한 뒤에 요구 성능이 변경되면 인스턴스 클래스를 변경할 수 있음
- 3가지 타입의 인스턴스의 종류를 제공함
1. **스탠다드 인스턴스 클래스**
    1. 대부분의 사용자 DB 요구 수준에 맞춘 클래스
    2. EBS 최적화 타입, EBS 스토리지를 사용하며 전용 네트워크로 연결됨
2. **메모리 최적화 인스턴스 클래스**
    1. 높은 수준의 성능을 요구하는 DB에 적합 → 충분한 메모리 제공해 쿼리 속도 향상 
    2. EBS 최적화 타입, EBS 스토리지를 사용하며 전용 네트워크로 연결됨
3. **성능 가속 인스턴스 클래스**
    1. 개발, 테스트, 비상용화를 고려한 인스턴스 
    2. 최대 디스크 처리 용량으로 디스크 읽기, 쓰기 작업 처리

### 스토리지

- IOPS ( Input Output operations Per Second ) : 초당 입출력 작업량
- IOPS 측정 방식 중요
- Mysql,MariaDB = 16KB / Oracle, PostgreSQL, Microsoft SQL = 8KB
- ex) Mysql, MariaDB 의 페이지 크기 : 16KB ⇒ 디스크에 16KB를 쓰면 하나의 I/O 작업으로 간주
- ex) 102,400KB (=100MB) 를 읽어야 할 때 : 페이지 크기가 16KB 이면 초당 6400개의 페이지를 읽어야 함. 페이지 1 번 읽기 = 1 I/O 이므로 최소 6400 IOPS의 성능이 필요함.
- 문제 : 당신은 Oracle DB 를 통해 초당 200MB 의 쓰기 작업을 해야한다. 이 때 얼마만큼의 IOPS 성능을 프로비저닝 해야 하는가?
- 즉, 페이지 크기랑 IOPS 성능은 반비례 관계!
1. **범용 SSD 스토리지** 
    1. 최소 20GB, 최대 64TB 볼륨 할당 가능
    2. 볼륨 1GB 당 3 IOPS 제공 but Max = 16,000 IOPS
2. **io1 스토리지 ( 프로비전 IOPS SSD )**
    1. 원하는 수준의 IOPS를 직접 설정 가능 
    2. 일반적으로 1GB 당 최소 50 IOPS 제공 (DB 엔진에 따라 달라짐)
    3. 볼륨당 64,000 IOPS 까지 프로비전 가능
    4. 문제 : 당신은 io1 스토리지를 사용하려고 하는데 최소 32,000 IOPS 의 성능이 필요하다. 이 때 프로비전해야 하는 스토리지의 최소 용량은?

### RDS Read Replicas (읽기 전용 복제본)

- 최대 5~15개까지의 읽기 전용 복제가 가능함.
- AZ 내에서도 가능하고 다른 AZ 혹은 리전에도 가능하다
- 복제는 비동기 식으로 이루어짐. 마스터에 쓰인 시간과 읽기 전용으로 읽는 시점의 차이 발생
- 문제 : 데이터 유실이 중요한 경우 재난 복구용으로 읽기 전용 복제본 생성으로 해결이 가능?
- 읽기 전용 DB이지만 권한을 부여해 DB로 승격시켜 이용할 수 있다.
- 읽기 전용에서는 select문만 사용이 가능하다.
- 일반적인 사례 : Product 레벨의 어플리케이션은 마스터 DB를 사용하고 있다. 근데 데이터 분석 팀에서 DB를 분석해서 무언가를 하려고 하는데 마스터 DB를 통해 조회를 하게 되면 DB에 부하가 많이 가게 된다. 이 때 읽기 전용 DB를 비동기 복제해 이를 통해 새로운 워크로드를 해결한다.

### Read Replicas의 비용 문제

- 일반적으로 데이터가 AZ를 넘나들 땐 비용이 발생하지만 RDS는 Fully Managed Service이다.
- 따라서 RDS Read Replicas를 이용하면 동일 리전 내의 AZ로의 이동은 비용이 청구되지 않는다.
- 하지만 다른 리전에 읽기 전용 DB를 통해 복제하려는 경우 네트워크에 대한 복제 비용이 발생

### RDS Multi AZ (다중 가용 영역)

- 사용 목적 : 고가용성과 재해 복구에 사용
- 다른 AZ에 동기식 복제로 스탠바이 인스턴스를 생성한다. → 마스터 DB의 모든 변화를 동기적으로 복제하는 것 → 마스터에 쓰이는 변경 사항이 스탠바이에도 그대로 복제됨.
- 멀티 AZ 배포는 DB 인스턴스 생성 당시, 생성 이후에 모두 설정이 가능하다.
- 마스터와 스탠바이는 하나의 DNS 네임을 갖고 어플리케이션은 DNS 네임을 통해 DB와 통신하기 때문에 마스터에 문제가 생겨도 스탠바이 DB에도 자동으로 장애 조치가 수행된다.
- AZ나 DB 인스턴스 혹은 스토리지에 문제가 생겼을 때 스탠바이 인스턴스를 마스터로 자동으로 승격시켜 고가용성을 이루기 위함.
- 문제 : 여러분은 다수의 트래픽을 처리하기 위해 sacle out을 해야 한다. 이 때 AWS RDS Multi AZ를 통해 scale out을 할 수 있나?
- 스탠바이 인스턴스가 생성되는 과정 : 마스터 DB의 스냅샷 생성 → 이를 바탕으로 스탠바이 DB에 복원 → 두 DB 간에 동기화 설정 → 스탠바이가 마스터의 변화를 모두 수용 → Multi AZ 상태

### AWS Aurora

- AWS의 독자적인 기술로 Postgres 와 Mysql과 호환되도록 만들어짐
- 오로라의 스토리지는 자동으로 확장됨 ⇒ 128 TB까지
- 데이터를 3개의 AZ에 걸쳐 6개의 복제본을 자동으로 생성한다.
- 마스터가 작동하지 않으면 30초 이내로 자동 장애 복구를 실행한다.
- 마스터에 문제가 생기면 읽기 전용 복제본 중 하나가 마스터가 되어 대체함.
- - - - - - - - 고급 기능 - - - - - - - -
- 오로라 서버리스 : 워크로드가 간헐적이거나 예측할 수 없을 때 유용
- 커스텀 엔드포인트를 설정해 특정 읽기 요청이 특정 읽기 복제본 인스턴스로 향하게 설정할 수 있다. (읽기 부하가 많은 작업에 활용) → 이 경우 리더 엔드포인트는 이용하지 않게 된다.
- 오로라 멀티 마스터 : 원래 마스터는 하나고 읽기 전용 복제본을 둬서 마스터에 장애가 생기면 이들 중 하나를 마스터로 승격시키는데, 멀티 마스터는 클라이언트가 다중 오로라 인스턴스와 상호작용하며 모든 인스턴스에서 쓰기가 가능하다. 하나의 인스턴스에 장애가 생기면 별도의 조치 없이 다른 모든 인스턴스가 공유 클러스터 볼륨에 데이터를 기록. → 고가용성(?) 지속적 가용성!
- Aurora Global Database : 1개의 메인 리전에서 읽기 쓰기를 하고 복제 지연 시간이 1초 미만인 보조 읽기 전용 리전을 5개까지 설정함.  기본 리전에 문제가 생기면 보조 리전을 승격 ⇒ 리전에 걸쳐서 데이터를 복제하는데 걸리는 시간이 평균 1초 미만이어야 한다.  → 글로벌 오로라 사용 !!

### Aurora DB 클러스터의 작동 방식

- 클라이언트는 Writer Endpoint와 상호작용한다.
- Writer Endpoint는 마스터 DB를 가리키고 있다.
- 마스터 DB는 여러 개의 읽기 전용 복제본을 두고 있다.
- Reader Endpoint는 여러 읽기 전용 복제본들과 연결되어 있고 사용자가 Reader Endpoint에 연결 될 때 적절한 읽기 전용 복제본으로 이동하도록 하는 Connection Load Balancing 역할을 수행한다.

### RDS Backup

- 자동 백업
    - 트랜잭션 로그는 매 5분마다 자동으로 백업된다.
    - 자동 백업 보유 기간은 1일부터 35일까지 설정 가능, 0일로 설정하면 백업 x
- 수동 DB 스냅샷
    - 유저가 수동으로 해야됨. 원하는 기간만큼 보유 가능
    - 인스턴스에 있는 모든 DB와 S3에 저장된 데이터가 모두 저장됨.
    - 동일 리전의 다수의 AZ에 저장된다.
- 사용 사례 : RDS를 정지해도 스토리지에 대한 비용을 내야 한다. 오랜 기간 정지해야 하는 경우 RDS를 정지하기 전에 DB 스냅샷을 찍어놓고 나중에 사용해야 할 때 이를 복원해서 사용하는 것이 비용을 훨씬 절약할 수 있다.

### Aurora Backup

- 자동 백업
    - 1일부터 35일까지 설정 가능, 비활성화 불가
- 수동 DB 스냅샷
    - 유저가 수동으로 해야 하며 스냅샷 이외에도 S3를 활용해 DB 복원을 할 수 있다.

### Aurora DB Cloning (복제)

- 기존 DB를 복제해 새로운 오로라 DB 클러스터를 만들 수 있음 → 스냅샷 복원보다 빠름
- 새 DB는 원본과 같은 클러스터 볼륨을 사용 → 시간이 지나면서 새 DB로 업데이트 되면 변경
- 매우 빠르고 비용 효율적이며 Production DB에 영향을 주지 않음.

### RDS & Aurora Security

- 저장된 데이터를 암호화 할 수 있다. → 데이터가 볼륨에 암호화된다.
- KMS를 활용해 마스터와 모든 복제본의 암호화가 이루어짐 → DB 처음 실행할 때 정의된다.
- 마스터를 암호화하지 않았다면 Read Replicas를 암호화할 수 없음.
- 암호화 되어 있지 않은 기존의 DB를 암호화하려면 암호화 되지 않은 DB의 스냅샷을 가져와서 암호화 된 DB의 형태로 스냅샷을 복원해야 한다.
- 클라이언트와 DB 간 전송 중 암호화 기능이 기본적으로 존재 → AWS 의 TLS 인증서 이용해야됨.
- 이들 또한 AWS 서비스이므로 IAM의 Role을 통해 엑세스 할 수 있다.
- 보안 그룹 (SG)을 활용해 네트워크의 접근을 제어할 수 있다.
- RDS와 Aurora에는 SSH 접속이 허용되지 않는다. / RDS 커스텀을 하면 이용 가능
- 감사 로그 작성을 활성화해 로그를 기록할 수 있다. → 시간이 지나면 자동으로 삭제 → 장기간 보관하고 싶다면 CloudWatch로 전송해야 한다.

### RDS 프록시

- RDS 프록시 : 어플리케이션이 DB 내에서 DB Connection Pool을 형성하고 공유할 수 있다.
- 어플리케이션을 RDS DB 인스턴스에 일일이 연결하는게 아니라 프록시에 연결해서 프록시가 연결 정보를 모은 풀을 만들어 관리한다. → RDS DB 인스턴스로 가는 연결이 줄어든다.
    
    ![Untitled](Udemy%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20b81e9e94c6d9413eaf059a59ca6d01c3/Untitled.png)
    
- **왜 프록시를 쓸까?**
    - DB의 CPU, RAM 등  DB 리소스의 부담 최소화 → DB의 효율성을 향상
    - DB open connection, DB timeout 최소화
    - 장애 조치 시간을 66% 개선해줌
        - 각 RDS 인스턴스에 연결된게 아니라 프록시에 연결되어 있어서 프록시가 장애가 발생한 인스턴스 외에 정상적인 인스턴스로만 연결을 처리해줌.
    - 보안성 강화
        - DB에 IAM 인증을 강제함 → IAM 인증을 통해서만 DB 연결 가능 → 자격 증명은 AWS Secrets Manager에 저장
        - public access 절대 불가. → vpc 내에서만 접근 가능 = 인터넷과 연결 x → 보안 굿
- 서버리스, 오토 스케일링, Multi AZ 지원 → 가용성 높음
- 람다랑 같이 쓰기 좋음 !!!
    - 람다는 오토 스케일링이 장점인데 스케일 아웃 하면서 각각 RDS 인스턴스랑 직접 연결한다?
    - DB open connection, time out 문제 많을걸? → 프록시랑 함께 쓰면 해결 가능.

![Untitled](Udemy%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20b81e9e94c6d9413eaf059a59ca6d01c3/Untitled.jpeg)

### Redshift

- OLAP DB에 최적화된 관리형 데이터 웨어하우스 서비스
- PostgreSQL 기반 / RDS와 별개로 존재
- 칼럼 단위로 데이터를 저장하는 칼럼형 스토리지 → 저장 속도가 빠르고 효율적
- 칼럼의 수를 줄이기 위해 압축 인코딩 실행
- 하나 이상의 컴퓨트 노드가 존재
    - 덴스 노드 :
        - 데이터의 저장 및 처리 담당
        - 마그네틱 스토리지에 최대 326TB, SSD에 최대 8192TB  데이터 저장 가능
        - 덴스 컴퓨트 노드 : 마그네틱 스토리지
        - 덴스 스토리지 노드 : SSD 사용
    - 리더 노드 : 중앙 제어와 쿼리 최적화 담당
    - 
- Redshift의 행은 다수의 컴퓨트 노드에 분산 저장됨. 분산 방식은 총 3가지
    - EVEN : default 방식. 리더 노드가 모든 컴퓨트 노드에 균일하게 분산됨
    - KEY : 단일 컬럼 내 값에 따라 데이터가 분산, 동일 값 컬럼은 동일 노드에 저장.
    - ALL : 각각의 테이블이 모든 컴퓨트 노드에 분산 저장

### AWS DMS (데이터베이스 마이그레이션 서비스)

- 기존 DB와 스키마를 복사해서 다른 DB에 저장
- 서로 다른 DB 엔진 간 마이그레이션 지원, RDBMS/NoSQL 마이그레이션 지원

### NoSQL

- NoSQL에 저장되는 데이터는 다양한 구조를 지니며 시간이 지나며 이런 구조가 바뀔 수 있음
- 콜렉션 요소로 구성. → 테이블이라고도 부름
    - 여러 종류의 데이터를 다양한 형식으로 정리한 document를 논리적으로 그룹화 한 단위

### Dynamo DB

- 다수의 파티션에 분산된 데이터 구조를 이영해 초당 수천 회의 읽기쓰기 작업 처리
- 파티션 : 테이블을 위한 스토리지 할당 영역, 다수의 AZ에 존재하는 SSD 이용
- 테이블 생성 시 기본 키와 데이터 타입을 명시해야 함
    - 기본 키 : 테이블 내 유일한 식별자여야 함. 아래의 두가지 방식중 하나 사용
    - 단순 기본 키 : 파티션 키 (=해시 키) 를 하나만 사용하는 경우
    - 복합 기본 키 : 파티션 키 + [ 소트 키(sort key) or 레인지 키(range key) ]사용
        - 파티션 키는 유일할 필요 x ⇒ 둘이 합치면 유일해야 함
- 테이블에서 아이템을 읽을 때 읽기 방식 선택 가능
    - 강한 일관성의 읽기 : 항상 최신 데이터 유지 가능
    - 종국적 일관성의 읽기 : 최근 쓰기 작업 내역 반영 못하는 경우도 있음

### ElastiCache

- 어플리케이션의 상태를 ElastiCache에 저장해 어플리케이션을 Stateless 하게 만듦.
- Cache Hit이 일어나면 캐시에서 데이터를 가져온다.
- Cache miss가 나면 DB에서 데이터를 읽어와서 캐시에 다시 쓴다.
- 가장 최근 데이터만 사용하는지 확인하는게 중요함 → 캐시 무효화 전략.
- 세션도 ElastiCache에 저장해서 Stateless 상태로 만듦.
- 레디스 : 고가용성 + 백업  / 맴캐시 : 가용성 낮음 + 백업 x
- 캐시 내의 모든 작업은 IAM을 지원하지 않는다. (사실 접근하는 것도 말이 안 됨)
- 어플리케이션에 코드 수정을 해줘야 사용 가능 !
- 데이터를 읽어오는 3가지 방법
    - Lazy Loading : 모든 읽기 데이터가 캐싱되고 데이터가 캐시에서 부실해질 수 있음
        
        → 캐시 히트가 없을 때만 발생한다. 
        
    - Write Trough : DB에 쓸 때마다 데이터 업데이트
    - Session Store : 일시적 세션 저장소로 사용
